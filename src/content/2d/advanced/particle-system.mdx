import Image from "next/image";
import {Callout} from "nextra/components"

# Particle System

Modern particle system developed for Studio.

<div className="flex flex-row">
    <Image src="/studio-docs/advanced/newParticleSystem/newParticleSystem.png" alt="overview" width={700} height={300} className="mt-6 rounded-xl overflow-hidden" />

    <div className="pl-6 pt-10">
        Users can integrate custom functionality by hooking into three primary lifecycle stages:
        - **Emitter Update:** Invoked once per frame for the emitter. All modules in this stage are executed every frame.

        - **Particle Spawn:** Triggered when a particle is created. All modules in this stage run at the start of the particle’s lifecycle.

        - **Particle Update:** Invoked once per frame for each particle. All modules in this stage are executed continuously throughout the particle’s lifetime.
    </div>
</div>

## Modules
Modules represent the "executable components" that can be added to the primary lifecycle stages. For example, the **Set Lifetime** module defines the duration of a particle’s existence. 
Intuitively, this is something you would configure when a particle is created, so this module should be added to the **Particle Spawn** stage.

As you can see, it is very intuitive to use this type of particle system. Modules are very self explanatory with what they do as well. It might be the
best if you experiment with the modules and create an understanding of this system yourself to better understand it. 

## Example Emitter

Let's create an effect you could use in one of your games. We'll make a small burst that goes out in every direction, similar to a confetti.

<Image src="/studio-docs/advanced/newParticleSystem/example-emitter-showcase.gif" alt="overview" width={300} height={300} className="mt-3 mb-4 ml-auto mr-auto rounded-xl overflow-hidden" />

Create a `Spawn Burst` module in **Emitter Update** lifecycle. Click on Select Module and select Spawn Burst.

- Set the period to 1 and amount to 50.

Right now particles are spawning, but they are not moving. Let's create a `Set Velocity` module inside **Particle Spawn**.

- Set Vel X Min and Vel X Max to -20 and 20 respectively.
- Set Vel Y Min and Vel Y Max to -40 and 0 respectively.

It takes too long for a particle to disappear, so let's add a `Set Lifetime` module inside **Particle Spawn**.

- Set the Lifetime Min and Max to 0.2 and 1 respectively.

Particles disappear very abruptly. Let's add `Color over Lifetime` and `Scale Over Lifetime` modules inside **Particle Update**.

- You don't need to change the default parameters here.

Let's add a `Gravity` module inside **Particle Update** so that our particles fall down.

- Set the Multiplier to 0.8.

Right now particles do not slow down at all, their velocities do not decay. Let's add a `Drag` module inside **Particle Update**.

- Set the Drag to 0.98. 

Lastly, since our particles spawn at the top-left position and also from a single point, let's center our particles
and add a small randomness to the spawn position. Inside **Particle Spawn**, create a `Set Position` module.

- Set Pos X Min and Pos X Max to 40 and 60 respectively.
- Set Pos Y Min and Pos Y Max to 40 and 60 respectively.

As you can see, it is very intuitive to build a particle system from scratch.

## Creating Custom Behaviours

You can access and subclass the main 3 module classes.

```ts
import { ShuraParticleSpawnModuleBase, ShuraParticleUpdateModuleBase, ShuraEmitterUpdateModuleBase } from "utils2D";
```

For example, you could create a circular motion module, and add it to your already created particle emitter in code:

```ts
class WaveMotion extends ShuraParticleUpdateModuleBase {
    amplitude = 20;
    frequency = 15;
    horizontalSpeed = 20;

    execute(particle, delta) {
        if (particle.waveTime === undefined) {
            particle.waveTime = Math.random() * Math.PI * 2; 
        }

        particle.waveTime += delta * this.frequency;
		particle.velocity.x = this.horizontalSpeed;
        particle.velocity.y = Math.cos(particle.waveTime) * this.amplitude;
    }
}


//...your other code goes here

export default class ParticleBehaviourCustomExample extends Script2D {
	_className = "ParticleBehaviourCustomExample";
	
	awake(props={}){
        this.props = props;
        const newModule = new WaveMotion()
        //access the cusotmParticleUpdateList and push your custom behaviour in there.
		this.particleEmitter.customParticleUpdateList.push(newModule);
        //then update the corresponding list
		this.particleEmitter.updateParticleUpdateList()
    }

    ...
}
```

Now your custom behaviour is applied on top of everything else and generates an unique motion:


<div className="grid grid-cols-2 grid-rows-1 gap-4">
    <Image src="/studio-docs/advanced/newParticleSystem/particle-motion-example.png" alt="overview" width={2000} height={300} className="mt-6 rounded-xl overflow-hidden w-full" />

    <div className="pl-0 flex flex-col">
        <Image src="/studio-docs/advanced/newParticleSystem/custom-example.gif" alt="overview" width={700} height={300} className="mt-6 rounded-xl overflow-hidden" />

        <p className="py-4">This example was created using the settings on the left side, and **WaveMotion** custom module added on top of particle update list.
        Spawn Rate is set to 1. White dot on the left side is simply there to show the particle system's center.</p>
    </div>
</div>

You could also then access this module, and manipulate its properties however you want to. It'll get updated in real-time:
<div className="grid grid-cols-2 grid-rows-1 gap-4 h- overflow-hidden rounded-xl">
    <div className="pb-4">
        ```ts



        gsap.to(
            newModule,
            {
                amplitude: 50,
                frequency: 5,
                horizontalSpeed: 30,
                yoyo:true,
                repeat: -1,
                duration: 1.0,
                ease:"none"
            }
        )



        ```
    </div>

    <div className="-mt-2.5">
        <Image src="/studio-docs/advanced/newParticleSystem/module-gsap-example.gif" alt="overview" width={293} height={300} className="mt-6 rounded-xl overflow-hidden" />
    </div>
</div>


### Implementation of Base Module Classes

```ts
interface ShuraSystemFrameState {
    spawnCount: 0,
}

export abstract class ShuraEmitterUpdateModuleBase {
    abstract execute(state: ShuraSystemFrameState, delta: number): number;
}
```

```ts
export abstract class ShuraParticleSpawnModuleBase {
    public abstract execute(particle: ShuraParticle): void;
}
```
```ts
export abstract class ShuraParticleUpdateModuleBase {
    public abstract execute(particle: ShuraParticle, delta: number): void
}
```

Simply extend the appropriate base class and override its execute method.